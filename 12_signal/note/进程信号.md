## 预备

![image-20240508234715567](C:\Users\13326\Desktop\note\img\image-20240508234715567.png)

```shell
[ws@VM]$ kill -l
 1) SIGHUP	 2) SIGINT	 3) SIGQUIT	 4) SIGILL	 5) SIGTRAP
 6) SIGABRT	 7) SIGBUS	 8) SIGFPE	 9) SIGKILL	10) SIGUSR1
11) SIGSEGV	12) SIGUSR2	13) SIGPIPE	14) SIGALRM	15) SIGTERM
16) SIGSTKFLT	17) SIGCHLD	18) SIGCONT	19) SIGSTOP	20) SIGTSTP
21) SIGTTIN	22) SIGTTOU	23) SIGURG	24) SIGXCPU	25) SIGXFSZ
26) SIGVTALRM	27) SIGPROF	28) SIGWINCH	29) SIGIO	30) SIGPWR
31) SIGSYS	

34) SIGRTMIN	35) SIGRTMIN+1	36) SIGRTMIN+2	37) SIGRTMIN+3
38) SIGRTMIN+4	39) SIGRTMIN+5	40) SIGRTMIN+6	41) SIGRTMIN+7	42) SIGRTMIN+8
43) SIGRTMIN+9	44) SIGRTMIN+10	45) SIGRTMIN+11	46) SIGRTMIN+12	47) SIGRTMIN+13
48) SIGRTMIN+14	49) SIGRTMIN+15	50) SIGRTMAX-14	51) SIGRTMAX-13	52) SIGRTMAX-12
53) SIGRTMAX-11	54) SIGRTMAX-10	55) SIGRTMAX-9	56) SIGRTMAX-8	57) SIGRTMAX-7
58) SIGRTMAX-6	59) SIGRTMAX-5	60) SIGRTMAX-4	61) SIGRTMAX-3	62) SIGRTMAX-2
63) SIGRTMAX-1	64) SIGRTMAX	
# 1 - 31：普通信号
# 34 - 64：实时信号
# 编号就是宏
```

**异步：**进程不需要一直等下去，而是继续执行下面的操作，不管其他进程的状态

> **处理信号常见三种方式：**
>
> 默认动作
>
> 自定义动作
>
> 忽略动作

> **预备**
>
> 进程如何识别信号？ 认识+动作
>
> 进程本质是被程序员编写的属性和逻辑的集合
>
> 当进程收到信号的时候，进程可能正在执行更重要的代码，所以信号不一定会被；立即处理
>
> 进程必须要有对信号保存的能力  -> 保存到`task_struct` -> 保存的是收到的信号编号（位图结构）
>
> 进程在处理信号的时候，一般有三种默认动作（默认、自定义、忽略） 【信号被捕捉】

![image-20240509000621753](C:\Users\13326\Desktop\note\img\image-20240509000621753.png)

PCB的管理者是OS，只有OS有权利修改PCB中的内容

无论未来学习多少种发送信号的方式，本质就是通过OS向目标进程发送信号

如：`kill命令`底层调用了系统调用`kill`系统调用



## 一、信号产生

```shell
[ws@VM]$ man 7 signal  # 查看信号的默认动作
 Signal     Value     Action   Comment
 ──────────────────────────────────────────────────────────────────────
 SIGHUP        1       Term    Hangup detected on controlling terminal  # Termimal：终止
                               or death of controlling process
 SIGINT        2       Term    Interrupt from keyboard
 SIGQUIT       3       Core    Quit from keyboard
 SIGILL        4       Core    Illegal Instruction
 SIGABRT       6       Core    Abort signal from abort(3)
 SIGFPE        8       Core    Floating point exception
 SIGKILL       9       Term    Kill signal
 SIGSEGV      11       Core    Invalid memory reference
 SIGPIPE      13       Term    Broken pipe: write to pipe with no
                               readers
 SIGALRM      14       Term    Timer signal from alarm(2)
 SIGTERM      15       Term    Termination signal
 SIGUSR1   30,10,16    Term    User-defined signal 1
 SIGUSR2   31,12,17    Term    User-defined signal 2
 SIGCHLD   20,17,18    Ign     Child stopped or terminated
 SIGCONT   19,18,25    Cont    Continue if stopped
 SIGSTOP   17,19,23    Stop    Stop process
 SIGTSTP   18,20,24    Stop    Stop typed at terminal
 SIGTTIN   21,21,26    Stop    Terminal input for background process
 SIGTTOU   22,22,27    Stop    Terminal output for background process

 The signals SIGKILL and SIGSTOP cannot be caught, blocked, or ignored. 
 # 不能捕获、阻止或忽略信号 9) SIGKILL和 19) SIGSTOP
```

**关于信号处理的行为的理解**

很多情况，大部分信号的默认处理动作都是终止进程

信号的意义：信号的不同，代表不同的事件，但是对事件发生之后的处理动作可以一样



CTRL+C：终止**前台**进程  -> OS将该组合建解释为2号信号SIGINT

**linux规定和用户进行交互只能有一个前台进程**

```
在 Linux 中，前台进程是指与用户直接交互的进程，通常是在终端中运行的程序或者 shell。当一个进程成为前台进程时，它会占据终端的控制权，接收并处理用户输入，并且终端会等待该进程执行完毕或者暂停运行。

Linux 规定同一个用户会话（session）中只能有一个前台进程，这意味着只有一个进程可以在终端中与用户进行交互。当用户在终端中启动一个程序或者执行一个命令时，该程序或命令会成为当前的前台进程，并且终端会等待它执行完毕或者暂停运行。

这个规定的目的是确保用户在终端中的交互操作能够顺利进行，避免混乱和冲突。如果允许多个前台进程同时运行，会导致用户输入的不确定性，可能会造成输入的混乱或者导致意外的结果。

因此，在 Linux 中，只有一个前台进程能够影响当前终端的行为，其他进程要么在后台运行，要么处于挂起状态。这样可以确保用户的交互操作是有序的，同时也能保证用户的输入能够被正确处理。
```

### 1、设置信号处理函数

```c
#include <signal.h>

typedef void (*sighandler_t)(int);

sighandler_t signal(int signum, sighandler_t handler);
// signal：信号编号，也可以填宏名称 
// 通过调用回调函数，默认动作 改为 自定义动作
```

`test.cc`

```cpp
#include <iostream>
#include <unistd.h>
#include <signal.h>

void handler(int signo) 
{
    std::cout << "进程捕获到了一个信号，信号编号是：" << signo << std::endl;
}

int main() 
{
    // 这里是signal的调用，并不是handler的调用
    // 仅仅是设置了对2号信号的捕捉方法，并不代表该方法被调用了
    // 一般这个方法不会执行，除非收到对应的信号
    signal(2, handler)；
        
    while (1) 
    {
        std::cout << "我是一个进程：" << getpid() << std::endl;
        sleep(1);
    }
    
    return 0;
}
```

### 2、 产生信号的方式

#### 2.1 通过键盘发送信号

​		如：`CTRL + C`：终止**前台**进程  -> OS将该组合建解释为 `2）SIGINT`

​               `	CTRL + \`：`3）SIGQUIT`

#### 2.2 系统调用

```shell
#include <sys/types.h>
#include <signal.h>

int kill(pid_t pid, int sig);
//return val: success: 0   fail: -1 errno
```

```c
#include <stdlib.h>

int atoi(const char *nptr);
// 成功后，该函数将转换后的整数作为值返回。 一旦遇到非数字字符，atoi 函数会停止转换并返回结果。
// 注意返回值是int，不要超过它的大小
```

#### 2.3 C语言封装的接口

```c
#include <signal.h>
int raise(int signo);  // kill(getpid(), signo)
// 给自己发送任意信号

#include <stdlib.h>
void abort(void);      // kill(getpid(), SIGABRT)
// 给自己发送6号信号SIGABRT
```

#### 2.4 硬件异常产生信号

信号产生，不一定非得用户显式的发送

硬件异常由软件异常自动触发，不用手动发信号

##### 2.4.1 除0理解

```c
#include <iostream>
#include <signal.h>
#include <unistd.h>


void catchSig(int signo)
{
    std::cout << "获取一个信号，编号是：" << signo << std::endl; 
}

int main() 
{
    signal(SIGFPE, catchSig);
    
    int a = 10; 
    a /= 0;  // 收到信号 8) SIGFPE (float point exception)
    while (1)
    {
        std::cout << "正在运行" << std::endl;
        sleep(1);
    }
}

// 现象：“获取一个信号，编号是：8” 一直刷屏
```

> **为什么除0，会终止进程?**  
>
> ​	当前进程会收到来自os的信号



> **OS给我发8号信号，它怎么知道我除0了？**   -- CPU会异常
>
> ![image-20240509193152477](C:\Users\13326\Desktop\note\img\image-20240509193152477.png)



> **为什么只除了一次0，但一直刷屏？**	
>
> 收到信号，不一定引起进程退出   -- 没有退出，可能还会被调度
>
> CPU内部的寄存器只有一份，但是寄存器中的内容，属于当前进程的上下文
>
> 我们没有能力修正这个问题
>
> 当进程被切换的时候，就有无数次状态寄存器被保存和恢复的过程
>
> 所以每一次恢复的时候，就让OS识别到了CPU内部的状态寄存器中的溢出标志是1



##### 2.4.2 野指针问题

```c
#include <iostream>
#include <signal.h>
#include <unistd.h>


void catchSig(int signo)
{
    std::cout << "获取一个信号，编号是：" << signo << std::endl; 
}

int main() 
{
    signal(SIGFPE, catchSig);
    
    int *p = nullptr; // 收到信号 11) SIGEGV（Segmentation fault(段错误)）
    // Invalid memory reference 非法地址引用
    *p = 10;
    while (1)
    {
        std::cout << "正在运行" << std::endl;
        sleep(1);
    }
}

// 现象：“获取一个信号，编号是：11” 一直刷屏
```

> **os发11号信号，os怎么知道野指针？**
>
> ![image-20240509201811027](C:\Users\13326\Desktop\note\img\image-20240509201811027.png)

> **刷屏现象**  -- 和除0一样



#### 2.5 由软件条件产生信号

管道  -- 读端关闭（**软件条件触发**），写端如果写，OS向写进程发送 `13）SIGPIPE`

##### 2.5.1 定时器软件条件

```c
#include <unistd.h>
unsigned int alarm(unsigned int seconds); // 系统调用
// 调用alarm函数可以设定一个闹钟，高速内核在seconds秒之后给当前进程发送14）SIGALRM信号，该信号的默认处理动作是终止当前进程
// return：0或者以前设定闹钟时间剩下的秒数
// 参数 seconds设为0表示取消闹钟
```

##### 2.5.2 理解”闹钟“就是用软件实现的

![image-20240509204832620](C:\Users\13326\Desktop\note\img\image-20240509204832620.png)

#### 2.6 总结

- 上面所有的信号产生，都要OS进行执行  -- 因为OS是进程的管理者
- 信号的处理是不是立即处理？   -- 合适的时候
- 信号不是立即处理，信号要被保存到PCB
- 一个进程没有收到信号的时候，已经知道了应该对合法信号的处理 -- 系统程序员已经在代码写好
- 如何理解OS向进程发信号  -- 修改进程PCB信号位图



### 3、进程退出时，核心转储问题

`Term`：正常结束

`Core`：OS除了终止进程，还会核心转储

`test.c`

```c
#include <stdio.h>
int main() 
{
    int a[10];
    a[100] = 0;
    return 0;
}
```

```shell
[ws@VM]$ ./test
Segmentation fault
```

```shell
[ws@VM]$ ulimit -a
core file size          (blocks, -c) 0           # 云服务器默认关闭了core file核心转储选项
open files                      (-n) 100001      # 默认能打开文件的个数
pipe size            (512 bytes, -p) 8           # 管道最多开8个，每个最大512 bytes

[ws@VM]$ ulimit -c 1024   # 打开core file，在OS中最多形成1024个block的数据块
[ws@VM]$ ./test
Segmentation fault (core dumped)  # 核心转储
[ws@VM-16-15-centos test]$ ll 
total 152
-rw------- 1 ws ws 249856 May  9 21:17 core.16438  #16438，引起core问题的进程的pid
-rwxrwxr-x 1 ws ws   8304 May  9 21:15 test
-rw-r--r-- 1 ws ws    103 May  9 21:15 test.c
```

核心转储：当进程出现异常的时候，我们将进程在对应的适时刻，在内存中的有效数据转储到磁盘中

**为什么要有核心转储？** -- 支持调试

gdb上下文中`core-file core.xxx`，快速定位错误

```shell
[ws@VM-16-15-centos test]$ gdb test
(gdb) core-file core.17476  # 
[New LWP 17476]
Core was generated by `./test'.
Program terminated with signal 11, Segmentation fault.
#0  main () at test.c:7
7	    a[100111] = 0;
Missing separate debuginfos, use: debuginfo-install glibc-2.17-326.el7_9.x86_64
(gdb) 
```



## 二、信号保存

### 1、概念

> - 实际执行信号的处理动作 -> **信号递达(Delivery)**。-> signal(signo, handler)中的handler函数就是递达该信号
> - 信号从**产生**到**递达**之间的状态 -> **信号未决(Pending)**  --收到信号尚未处理（信号先被保存起来不处理）
> - 进程可以选择**阻塞（Block）**某个信号  -- 信号被阻塞，将保持在未决状态，直到解除再递达
> - 被阻塞的信号产生时将保存在未决状态，直到进程解除对此信号的阻塞，才执行递达的动作
> - 注意：**阻塞和忽略是不同的**。只要信号被阻塞就不会递达，而忽略是在递达之后可选的一种处理动作（忽略就是递达的一种）（没有收到某个信号，也可以阻塞它）

### 2、信号在内核中的表示

#### pending位图和block位图

进程在任意时刻可能收到OS发送的信号，该信号可能不会被立即递达，所以暂时保存

**处于pending位图对应的信号，称该信号处于未决状态**

![image-20240509230845656](C:\Users\13326\Desktop\note\img\image-20240509230845656.png)

**理解系统调用signal(signo, handler)**

本质拿着这个信号在数组对应的位置中，将handler函数地址填入到对应数组内容

如果产生该信号时，先修改pending位图该信号编号，然后在block位图中查看是否被阻塞，如果没有，拿着信号的编号在访问数组该信号的处理方法

> **结论**
>
> 如果一个信号没有产生，并不妨碍它可以先被阻塞
>
> 进程为何能够识别信号呢？-- 程序员在设置信号这类机制的时候，在内核中为每个进程都设置好了对应的三种结构：pending位图、block位图、handler表

进程在某一时刻收到了大量的同一个**普通**信号，只能记录下一个，其他信号都丢失了



## 三、信号的捕捉（重要）

![image-20240511010242528](C:\Users\13326\Desktop\note\img\image-20240511010242528.png)

![image-20240511010451466](C:\Users\13326\Desktop\note\img\image-20240511010451466.png)

## 四、函数

### 1、sigset_t

```
每个信号只有一个bit的未决标志(pending位图)，非0即1，不记录该信号产生了多少次，阻塞标志也是这样的（block位图）。
因此，未决和阻塞标志可以用相同的数据类型sigset_t来存储。
sigset_t称为信号集，这个类型可以表示每个信号的“有效”或“无效”状态。在阻塞信号集中，有/无效表示该信号是否被阻塞。在未决信号集中有/无效表示该信号是否处于未决状态。
阻塞信号集（block信号集）也叫做当前进程的信号屏蔽字。（这里的屏蔽理解为阻塞而不是忽略）
```

### 2、信号集操作函数

```c
// 3号手册
#include <signal.h>

int sigemptyset(sigset_t *set); // 清空，全置0
int sigfillset(sigset_t *set);	// 全置1
int sigaddset(sigset_t *set, int signum);  // 添加一个信号
int sigdelset(sigset_t *set, int signum);  // 删除一个信号
// return：success 0   fail：-1

int sigismember(const sigset_t *set, int signum);  // 判断一个信号是否在该集合
// return：包含则返回1，不包含返回0，出错返回-1
```

### 3、sigprocmask

可以读取或更改进程的信号屏蔽字（**阻塞信号集**）

```c
// man 2
#include <signal.h>

int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);
// return：succes：0  fail：-1
```

**how**参数

```
SIG_BLOCK:set包含了希望添加到当前信号屏蔽字的信号，相当于mask |= set
SIG_UNBLOCK:set包含了我们希望从当前信号屏蔽字中解除则色的信号，相当于mask=mask&~set
SIG_SETMASK:设置当前西卡信号屏蔽字为set所指向的值，相当于mask= set
```

oldset：输出型参数，保存老的信号屏蔽字

### 4、sigpending

获取进程的pending信号集

```c
// man 2
#include <signal.h>

int sigpending(sigset_t *set);
// 输出型参数，覆盖式获取，set不清0也没关系
// return：s0  f-1
```

> 总结：
>
> 1、signal(signo, handler)处理handler_t handler的
>
> 2、sigpromask处理block信号集的
>
> 3、sigpending处理pending信号集的
>
> 三个关于信号的内核数据结构都有特定的函数处理了